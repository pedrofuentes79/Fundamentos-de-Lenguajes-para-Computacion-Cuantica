\documentclass[12pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{float}

% Packages for mathematical typesetting
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}


% Packages for quantum circuits
\usepackage{xypic}
\usepackage{qcircuit}

% Package for ket notation
\usepackage{braket}

% Package for proof trees
\usepackage{bussproofs}
\usepackage{lscape}

% Title and author
\title{Fundamentos de Lenguajes para Computación Cuántica}
\author{Pedro Fuentes Urfeig, Matías Mesch}

\newcommand\qbit{\textit{qubit}}
\newcommand\pqbit{\ensuremath{\mathbf{qubit}}}
\newcommand{\p}[1]{\mathbf{#1}}
\newcommand{\pmultimap}{\multimap}
\newcommand{\pwith}{\&}
\newcommand{\sdot}{\cdot}
\newcommand{\Plus}{+}
\newcommand{\topintro}{\top}
\newcommand{\elimone}{\delta_1}
\newcommand{\elimwith}{\delta_{\&}}
\newcommand{\elimtens}{\delta_{\otimes}}
\newcommand{\elimzero}{\delta_{0}}
\newcommand{\elimplus}{\delta_{\oplus}}
\newcommand{\inl}{\text{inl}}
\newcommand{\inr}{\text{inr}}
\newcommand{\abstr}[1]{#1.}
\newcommand{\one}{1}
\newcommand{\zero}{0}

\newcommand{\pair}[2]{\langle #1, #2 \rangle}
\newcommand{\ketbra}[2]{\ket{#1}\bra{#2}}
\newcommand{\defeq}{\mathrel{\mathop:}=}

\begin{document}

\section{Ejercicio I.15}
Definir las compuertas $\textbf{And}$ y $\textbf{Or}$.

And := $\lambda x. \lambda y. match(x, w.match(y, a.inl(*), b.inr(*)), z.inr(*))$

Or := $\lambda x. \lambda y. match(x, a.inr(*), b.match(y, c.inl(*), d.inr(*)))$

\section{Ejercicio I.16}
Dar el tipo de $\textbf{And}$ y $\textbf{Or}$.

\begin{landscape}
\subsection{Tipo de And}

El tipo de $\textbf{And}$ es: $\text{Bool} \to \text{Bool} \to \text{Bool}$, donde $\text{Bool} = \top \lor \top$.
Tomé $\Gamma = x : \text{Bool}, y : \text{Bool}$.

\begin{prooftree}
  % Primera premisa del match externo: axioma para x
  \AxiomC{}
  \RightLabel{$ax$}
  \UnaryInfC{$\Gamma \vdash x : \top \lor \top$}
  
  % Segunda premisa del match externo: match interno (y)
  % Sub-árbol para el match de y
      \AxiomC{}
      \RightLabel{$ax$}
      \UnaryInfC{$\Gamma \vdash y : \top \lor \top$}
      
      \AxiomC{}
      \RightLabel{$\top_i$}
      \UnaryInfC{$\Gamma, a : \top \vdash * : \top$}
      \RightLabel{$\lor_{i_1}$}
      \UnaryInfC{$\Gamma, a : \top \vdash inl(*) : \top \lor \top$}
      
      \AxiomC{}
      \RightLabel{$\top_i$}
      \UnaryInfC{$\Gamma, b : \top \vdash * : \top$}
      \RightLabel{$\lor_{i_2}$}
      \UnaryInfC{$\Gamma, b : \top \vdash inr(*) : \top \lor \top$}
      
      \RightLabel{$\lor_e$}
      \TrinaryInfC{$\Gamma \vdash match(y, a.inl(*), b.inr(*)) : \text{Bool}$}
  
  % Tercera premisa del match externo: rama derecha
  \AxiomC{}
  \RightLabel{$\top_i$}
  \UnaryInfC{$\Gamma, z : \top \vdash * : \top$}
  \RightLabel{$\lor_{i_2}$} 
  \UnaryInfC{$\Gamma, z : \top \vdash inr(*) : \text{Bool}$}
  
  % Match externo (x) - combina las 3 premisas
  \RightLabel{$\lor_e$}
  \TrinaryInfC{$\Gamma \vdash match(x, w.match(y, a.inl(*), b.inr(*)), z.inr(*)) : \text{Bool}$}
  
  % Abstracciones lambda
  \RightLabel{$\to_i$}
  \UnaryInfC{$x : \text{Bool} \vdash \lambda y. match(x, w.match(y, a.inl(*), b.inr(*)), z.inr(*)) : \text{Bool} \to \text{Bool}$}
  
  \RightLabel{$\to_i$}
  \UnaryInfC{$\vdash \lambda x. \lambda y. match(x, w.match(y, a.inl(*), b.inr(*)), z.inr(*)) : \text{Bool} \to \text{Bool} \to \text{Bool}$}
\end{prooftree}
\end{landscape}
\begin{landscape}
  \subsection{Tipo de Or}
  El tipo de $\textbf{Or}$ es: $\text{Bool} \to \text{Bool} \to \text{Bool}$, donde $\text{Bool} = \top \lor \top$.
  Tomé $\Gamma = x : \text{Bool}, y : \text{Bool}$ y $\Gamma_1 = \Gamma, b : \top$
  
  \begin{prooftree}
    % Primera premisa del match externo: axioma para x
    \AxiomC{}
    \RightLabel{$ax$}
    \UnaryInfC{$\Gamma \vdash x : \top \lor \top$}
    
    % Segunda premisa del match externo: rama izquierda - inr(*)
    \AxiomC{}
    \RightLabel{$\top_i$}
    \UnaryInfC{$\Gamma, a : \top \vdash * : \top$}
    \RightLabel{$\lor_{i_2}$}
    \UnaryInfC{$\Gamma, a : \top \vdash inr(*) : \top \lor \top$}
    
    % Tercera premisa del match externo: match interno de y
      \AxiomC{}
      \RightLabel{$ax$}
      \UnaryInfC{$\Gamma_1 \vdash y : \top \lor \top$}
      
      \AxiomC{}
      \RightLabel{$\top_i$}
      \UnaryInfC{$\Gamma_1, c : \top \vdash * : \top$}
      \RightLabel{$\lor_{i_1}$}
      \UnaryInfC{$\Gamma_1, c : \top \vdash inl(*) : \top \lor \top$}
      
      \AxiomC{}
      \RightLabel{$\top_i$}
      \UnaryInfC{$\Gamma_1, d : \top \vdash * : \top$}
      \RightLabel{$\lor_{i_2}$}
      \UnaryInfC{$\Gamma_1, d : \top \vdash inr(*) : \top \lor \top$}
      
      \RightLabel{$\lor_e$}
      \TrinaryInfC{$\Gamma_1 \vdash match(y, c.inl(*), d.inr(*)) : \text{Bool}$}
    
    % Match externo (x) - combina las 3 premisas
    \RightLabel{$\lor_e$}
    \TrinaryInfC{$\Gamma \vdash match(x, a.inr(*), b.match(y, c.inl(*), d.inr(*))) : \text{Bool}$}
    
    % Abstracciones lambda
    \RightLabel{$\to_i$}
    \UnaryInfC{$x : \text{Bool}, y : \text{Bool} \vdash match(x, a.inr(*), b.match(y, c.inl(*), d.inr(*))) : \text{Bool}$}
    
    \RightLabel{$\to_i$}
    \UnaryInfC{$x : \text{Bool} \vdash \lambda y. match(x, a.inr(*), b.match(y, c.inl(*), d.inr(*))) : \text{Bool} \to \text{Bool}$}
    
    \RightLabel{$\to_i$}
    \UnaryInfC{$\vdash \lambda x. \lambda y. match(x, a.inr(*), b.match(y, c.inl(*), d.inr(*))) : \text{Bool} \to \text{Bool} \to \text{Bool}$}
\end{prooftree}
  
\end{landscape}



\section{Ejercicio II.5}

Demostrar el teorema 4.12. En \textbf{Set}, los epimorfismos son las funciones sobreyectivas.
Osea, toda flecha $f: A \to B$ cumple que $\forall b \in B, \exists a \in A$ tal que $f(a) = b$.

Ida: f es un epimorfismo $\implies$ f es sobreyectiva. 
Vamos a demostrarlo por el contrarrecíproco. Es decir f no es sobreyectiva $\implies$ f no es un epimorfismo.
Entonces, quiero buscar $g: B \to C, h: B \to C$ con $g \neq h$ pero $g \circ f = h \circ f$.

La idea es que $g(b_0) \neq h(b_0)$ para algún $b_0 \in B$, pero que tengan el mismo comportamiento sobre la imagen de $f$.

Por simpleza tomemos $g(b) = 0$ y $h(b) = \begin{cases} 0 & \text{si } b \neq b_0 \\ 1 & \text{si } b = b_0 \end{cases}$

De este modo, $g(b_0) \neq h(b_0)$, por ende $g \neq h$.

Veamos ahora $g \circ f = h \circ f \iff (g \circ f)(a) = (h \circ f)(a) \forall a \in A$.
Vemos que $f(a) \neq b_0 \forall a \in A$. Luego,
\begin{itemize}
    \item $(g \circ f)(a) = g(f(a)) = 0$, pues $g$ es constante y $f(a) \in Dom(g)$
    \item $(h \circ f)(a) = h(f(a)) = 0$, pues $f(a) \neq b_0$ por hipótesis.
\end{itemize}

Luego, vemos que $g \circ f = h \circ f$ para todo $a \in A$, pero no vale que $g = h$, por ende $f$ no es un epimorfismo.


Vuelta: f es sobreyectiva $\implies$ f es un epimorfismo.
Quiero ver que $g \circ f = h \circ f \implies g = h$, para $g: B \to C, h: B \to C$.
Como asumo que $f$ es sobreyectiva, sé que toda su imagen $B$ está alcanzada por un $f(a)$, con $a \in A$.

Vamos a demostrarlo por absurdo.
Asumamos que $g(b_1) \neq h(b_1)$ para algún $b_1 \in B$.
Luego, como $b_1 \in B$, sabemos que existe un $a_1 \in A$ tal que $f(a_1) = b_1$.

Entonces, como sabemos que $g \circ f = h \circ f$, tenemos que:

$$(g \circ f)(a_1) = (h \circ f)(a_1)$$
$$g(f(a_1)) = h(f(a_1))$$
$$g(b_1) = h(b_1)$$

Absurdo! Pues habíamos asumido que $g(b_1) \neq h(b_1)$.
Luego, $g = h$.
Entonces, $f$ es un epimorfismo.

\qed

\section{Ejercicio III.15}

Dar un circuito que genere el estado $\frac{1}{\sqrt{2}} (\ket{000} + \ket{111})$ a partir de la entrada $\ket{000}$.

Un circuito que cumple es el siguiente:
\[
\Qcircuit @C=1em @R=.7em {
  & \lstick{|0\rangle} & \gate{H} & \ctrl{1} & \qw      & \qw \\
  & \lstick{|0\rangle} & \qw      & \targ    & \ctrl{1} & \qw \\
  & \lstick{|0\rangle} & \qw      & \qw      & \targ    & \qw \\
}
\]

Veamos que esto es correcto. 
Comenzamos con el estado $\ket{\psi_0} = \ket{000}$, que es lo mismo que $\ket{0} \otimes \ket{0} \otimes \ket{0}$.
Vemos que al aplicar Hadamard al primer qubit obtenemos lo siguiente:
$$\ket{\psi_1} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) \otimes \ket{0} \otimes \ket{0}$$

Luego, al aplicar el CNOT con el control en el primer qubit y el target en el segundo, tenemos lo siguiente:
$$\ket{\psi_2} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) \otimes \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) \otimes \ket{0}$$

Esto es porque el control es el primer qubit. Entonces, si el primer qubit es 0, no hace nada (entonces queda en 0 el segundo). Pero si el primero es 1, se cambia el segundo qubit a 1.

Luego, al aplicar el CNOT con el control en el segundo qubit y el target en el tercero, sucede lo mismo pero en el tercer qubit.

$$\ket{\psi_3} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) \otimes \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) \otimes \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) $$

Que es lo mismo que $\frac{1}{\sqrt{2}} (\ket{000} + \ket{111})$.

\section{Ejercicio III.24}
En el protocolo BB84, Alice y Bob descartan todos los bits en los que eligieron bases distintas, y se quedan con una clave candidata. Luego eligen al azar algunos bits de esa clave, los comparan públicamente y los descartan, para detectar la posible presencia de un espía (Eve). ¿Cuántos bits necesitan comparar Alice y Bob para tener al menos un 90\% de probabilidad de detectar la presencia de Eve, suponiendo que Eve mide siempre en una base al azar?


En la comunicación, si Eve está espiando el canal y mide en una base al azar, va a afectar a lo que reciba Bob (va a medirlo y luego enviarle su medición a Bob). Ya que mide en una base al azar, va a medir correctamente o incorrectamente con la misma probabilidad ($\frac{1}{2}$ para cada caso). Luego, cuando Bob reciba esa medición, va a elegir una base al azar para medirlo. Entonces, a pesar de que no coincidan las bases de Bob y Eve, Bob tiene una probabilidad de $\frac{1}{2}$ de medir lo mismo que había enviado Alice. Esto es porque si difieren las bases, los valores de $0$ y $1$ (en cada base) estarían entrelazados, y Bob al elegir una base al azar, va a medir correctamente con probabilidad $\frac{1}{2}$.


Para detectar un error, Alice y Bob comparan algunos bits de su clave candidata (es decir, los bits en los que eligieron la misma base). Si hay alguna diferencia, significa que hay alguien espiando la comunicación, ya que si Alice envió un valor en una base, y Bob lo midió en esa base, deberían ser el mismo; la única opción para que no coincidan es que hay alguien alterando la comunicación. De todos modos, puede suceder que a pesar de que Eve haya medido en una base distinta a la de Alice, Bob obtenga el mismo valor que Alice envió.
Asumimos que Bob y Alice miden en la misma base, ya que estamos hablando de \textbf{bits de la clave candidata}, que son los que Bob y Alice coinciden en la base.

Veamos la probabilidad de que se detecte un error en 1 bit. Sea A el evento en el que: "Eve mide en una base distinta a la de Alice" y B el evento en el que: "Bob no mide lo mismo que Alice envió".

$$P(\text{detectar error en 1 bit}) = P(A) \cdot P(B) = \frac{1}{2} \cdot \frac{1}{2}  = \frac{1}{4}$$

Luego, la probabilidad de que no se detecte un error en 1 bit es $1 - \frac{1}{4} = \frac{3}{4}$.

Veamos que sucedería en $n$ bits. Para que no se detecte un error en $n$ bits, Eve tendría que pasar desapercibida en todos los bits. Luego, la probabilidad de que no se detecte un error en $n$ bits es $(\frac{3}{4})^n$.

Lo que queremos es ver qué $n$ necesitamos para que la probabilidad de \textbf{detectar un error} sea al menos $0.9$

$$P(\text{detectar un error en $n$ bits}) = 1 - P(\text{no detectar un error en n bits}) = 1 - \left(\frac{3}{4}\right)^n$$

Queremos que esta probabilidad sea al menos $0.9$.

$$1 - \left(\frac{3}{4}\right)^n \geq 0.9$$

$$0.1 \geq \left(\frac{3}{4}\right)^n$$

$$ln(0.1) \geq n \cdot ln\left(\frac{3}{4}\right)$$

$$\frac{ln(0.1)}{ln\left(\frac{3}{4}\right)} \leq n$$

Dado que $\frac{ln(0.1)}{ln\left(\frac{3}{4}\right)} \approx 8.003$, con tomar $n = 9$ nos alcanza.

\section{Algoritmo de codificación superdensa}

\subsection{Traza del algoritmo para los distintos inputs}
% TODO: escribir esto mejor
El algoritmo de codificación superdensa tiene como objetivo transmitir 2 bits clásicos enviando 1 qubit entre un emisor llamado Alice y un receptor llamado Bob.
\\ Se parte de un estado inicial de bell $\beta_{00} = \frac{1}{\sqrt{2}} (\ket{00}+ \ket{11})$
\\ Alice hace: $(Z^{b1}X^{b2} \otimes I) \beta_{00}$
\\ Bob aplica la siguiente transformación al resultado de lo obtenido por Alice: $(H \otimes I) CNOT$ y realiza una medición.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{algoritmo_codificacion.png}
    \label{fig:algoritmo_codificacion}
\end{figure}

\subsubsection{Traza del algoritmo para bit 00}
Parte Alice:
$\\ (Z^{0}X^{0} \otimes I) \beta_{00} = (I \otimes I) \beta_{00}
\\ = (I \otimes I) \beta_{00} = \beta_{00}
\\ \frac{1}{\sqrt{2}} (\ket{00}+ \ket{11})
$
\\
Parte Bob:
$
\\ (H\otimes I) CNOT  \frac{1}{\sqrt{2}} (\ket{00}+ \ket{11})
\\ = (H\otimes I)  \frac{1}{\sqrt{2}} (CNOT \ket{00} + CNOT \ket{11})
\\ = (H\otimes I)  \frac{1}{\sqrt{2}} (\ket{00} + \ket{10})
\\ = \frac{1}{\sqrt{2}} ((H\otimes I)\ket{00} + (H\otimes I) \ket{10})
\\ = \frac{1}{\sqrt{2}} ((\frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \otimes \ket{0}) 
+ (\frac{1}{\sqrt{2}} (\ket{0}) - \ket{1} ) \otimes \ket{0})
\\ = \frac{1}{\sqrt{2}} ( \frac{1}{\sqrt{2}} (\ket{00} + \ket{10}) + \frac{1}{\sqrt{2}} (\ket{00} - \ket{10}) )
\\ = \frac{1}{2} (\ket{00} + \ket{10} + \ket{00} - \ket{10})
\\ = \frac{1}{2} (2 \ket{00}) = \ket{00}
$
\subsection{Traza del algoritmo para bit 01}
Parte Alice:
$\\ (Z^{0}X^{1} \otimes I) \beta_{00} = (X \otimes I) \beta_{00}
\\ = (X \otimes I) \frac{1}{\sqrt{2}} (\ket{00}+ \ket{11}
\\ = \frac{1}{\sqrt{2}} ((X \otimes I) \ket{00}+ (X \otimes I) \ket{11})
\\ = \frac{1}{\sqrt{2}} ( (X \ket{0})\otimes (I\ket{0}) + (X \ket{1}) \otimes(I \ket{1}))
\\ = \frac{1}{\sqrt{2}} ( \ket{1} \otimes \ket{0} + \ket{0} \otimes \ket{1})
\\ = \frac{1}{\sqrt{2}} ( \ket{10} + \ket{01} ) = \beta_{01}
$
\\
Parte Bob:
$
\\ (H\otimes I) CNOT\beta_{01}
\\ = (H\otimes I) (CNOT \frac{1}{\sqrt{2}} ( \ket{10} + \ket{01} )))
\\ = (H\otimes I) (\frac{1}{\sqrt{2}} ( CNOT \ket{10} + CNOT \ket{01} ))
\\ = (H\otimes I) (\frac{1}{\sqrt{2}} ( \ket{11} + \ket{01} ))
\\ = \frac{1}{\sqrt{2}} (  (H\otimes I) \ket{11} +  (H\otimes I)\ket{01} )
\\ = \frac{1}{\sqrt{2}} (  H\ket{1} \otimes I\ket{1} +  H\ket{0} \otimes I\ket{1} )
\\ = \frac{1}{\sqrt{2}} (  ((\frac{1}{\sqrt{2}} (\ket{0} - \ket{1})) \otimes \ket{1}) + (\frac{1}{\sqrt{2}} (\ket{0} + \ket{1})) \otimes \ket{1} )
\\ =\frac{1}{\sqrt{2}} (  ((\frac{1}{\sqrt{2}} (\ket{01} - \ket{11}))) +  (\frac{1}{\sqrt{2}} (\ket{01} + \ket{11})))
\\ = \frac{1}{\sqrt{2}} (\frac{1}{\sqrt{2}} (\ket{01} - \ket{11} + \ket{01} + \ket{11}))
\\ = \frac{1}{2} (2\ket{01})
\\ = \ket{01}
$ 
\subsection{Traza del algoritmo para bit 10}
Parte Alice:
\\$(Z^{1}X^{0} \otimes I) \beta_{00} = (Z \otimes I) \beta_{00}  
\\ = (Z \otimes I) \frac{1}{\sqrt{2}} (\ket{00}+ \ket{11}
\\ = \frac{1}{\sqrt{2}} ( (Z \otimes I)\ket{00} + (Z \otimes I)\ket{11} )
\\ = \frac{1}{\sqrt{2}} ( \ket{00} - \ket{11} ) = \beta_{10}
$
\\
Parte Bob:\\
$
(H\otimes I) CNOT\beta_{10}
\\ = (H\otimes I) (CNOT \frac{1}{\sqrt{2}} ( \ket{00} - \ket{11} ) ))
\\ = (H\otimes I) (\frac{1}{\sqrt{2}} ( CNOT \ket{00} - CNOT\ket{11} ))
\\ = (H\otimes I) (\frac{1}{\sqrt{2}} ( \ket{00} - \ket{10} ))
\\ = \frac{1}{\sqrt{2}} (  (H\otimes I) \ket{00} -  (H\otimes I)\ket{10} )
\\ = \frac{1}{\sqrt{2}} (  H\ket{0} \otimes I\ket{0} -  H\ket{1} \otimes I\ket{0} )
\\ = \frac{1}{\sqrt{2}} (  ((\frac{1}{\sqrt{2}} (\ket{0} + \ket{1})) \otimes \ket{0}) -  (\frac{1}{\sqrt{2}} (\ket{0} - \ket{1})) \otimes \ket{0} )
\\ =\frac{1}{\sqrt{2}} (  ((\frac{1}{\sqrt{2}} (\ket{00} + \ket{10}))) -  (\frac{1}{\sqrt{2}} (\ket{00} - \ket{10})))
\\ = \frac{1}{\sqrt{2}} (\frac{1}{\sqrt{2}} (\ket{00} + \ket{10} - \ket{00} + \ket{10}))
\\ = \frac{1}{2} (2\ket{10})
\\ = \ket{10}
$ 

\subsection{Traza del algoritmo para bit 11}
Parte Alice:
\\$(Z^{1}X^{1} \otimes I) \beta_{00} = (ZX \otimes I) \beta_{00}  
\\ = (ZX \otimes II) \beta_{00}
\\ = (Z \otimes I) ((X \otimes I) \beta_{00})
\\ = (Z \otimes I) ((X \otimes I) \frac{1}{\sqrt{2}} (\ket{00}+ \ket{11})
\\ = (Z \otimes I) (\frac{1}{\sqrt{2}} ((X \otimes I) \ket{00}+ (X \otimes I) \ket{11}))
\\ = (Z \otimes I) (\frac{1}{\sqrt{2}} ( (X \ket{0})\otimes (I\ket{0}) + (X \ket{1}) \otimes(I \ket{1})))
\\ = (Z \otimes I) (\frac{1}{\sqrt{2}} ( \ket{1} \otimes \ket{0} + \ket{0} \otimes \ket{1}))
\\ = (Z \otimes I) (\frac{1}{\sqrt{2}} ( \ket{10} + \ket{01} ))
\\ = \frac{1}{\sqrt{2}} ( (Z \otimes I)\ket{10} + (Z \otimes I)\ket{01} )
\\ = \frac{1}{\sqrt{2}} ( -\ket{10} + \ket{01} ) = \beta_{11}
$
\\
Parte Bob:\\
$
(H\otimes I) CNOT\beta_{11}
\\ = (H\otimes I) (CNOT \frac{1}{\sqrt{2}} ( \ket{01} - \ket{10} ))
\\ = (H\otimes I) (\frac{1}{\sqrt{2}} ( CNOT \ket{01} - CNOT\ket{10} ))
\\ = (H\otimes I) (\frac{1}{\sqrt{2}} ( \ket{01} - \ket{11} ))
\\ = \frac{1}{\sqrt{2}} (  (H\otimes I) \ket{01} -  (H\otimes I)\ket{11} )
\\ = \frac{1}{\sqrt{2}} (  H\ket{0} \otimes I\ket{1} -  H\ket{1} \otimes I\ket{1} )
\\ = \frac{1}{\sqrt{2}} (  ((\frac{1}{\sqrt{2}} (\ket{0} + \ket{1})) \otimes \ket{1}) -  (\frac{1}{\sqrt{2}} (\ket{0} - \ket{1})) \otimes \ket{1} )
\\ =\frac{1}{\sqrt{2}} (  ((\frac{1}{\sqrt{2}} (\ket{01} + \ket{11}))) -  (\frac{1}{\sqrt{2}} (\ket{01} - \ket{11})))
\\ = \frac{1}{\sqrt{2}} (\frac{1}{\sqrt{2}} (\ket{01} + \ket{11} - \ket{01} + \ket{11}))
\\ = \frac{1}{2} (2\ket{11})
\\ = \ket{11}
\\ \bra{11} \ket{11} ^2 = 1 \implies
$ 
la probabilidad de caer en el estado $\ket{11}$ es del 100\%

\subsection{Algoritmo de condensación en cálculo lambda para computación cuántica con control clásico}

Sean las siguientes definiciones:
\begin{enumerate}
    \item \textbf{EPR} : $!(\top \multimap (\text{qbit} \otimes \text{qbit}))$ \\
    \quad $\text{EPR} = \lambda x. \text{CNOT} \langle H(\text{new } 0), \text{new } 0 \rangle$
    
    \item \textbf{U} : $!(\text{qbit} \multimap (\text{bit} \otimes \text{bit} \multimap \text{qbit}))$ \\
    \quad $U = \lambda q. \lambda \langle x,y \rangle. \text{if } x \text{ then } (\text{if } y \text{ then } U_{11} q \text{ else } U_{10} q)$ \\
    \quad $\quad \text{else } (\text{if } y \text{ then } U_{01} q \text{ else } U_{00} q)$
\end{enumerate}

donde:
$$U_{00} = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}, \quad U_{01} = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \quad U_{10} = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}, \quad U_{11} = \begin{pmatrix} 0 & 1 \\ -1 & 0 \end{pmatrix}.$$
\vspace{1em}
\noindent \textbf{Algoritmo:}
\begin{align*}
    \textbf{Condensacion} &: ! \text{bit} \multimap ! \text{bit} \multimap !(\text{bit} \otimes \text{bit}) \\
    \text{Condensacion} &= \lambda b_1 \lambda b_2. \left( \text{let } \langle x,y \rangle = \text{EPR}^* \text{ in } \right. \\
    &\quad \left. \text{let } a = U x \langle b_1,b_2 \rangle \text{ in } \right. \\ % Salto de línea aquí
    &\quad \left. \text{let } \langle q_1,q_2 \rangle = \text{CNOT} \langle a,y \rangle \text{ in } \langle \text{meas}((H q_1), \text{meas } q_2) \rangle \right)
\end{align*}

\subsection{Evaluación paso a paso}
 
 $[\emptyset, (\lambda b_1. \lambda b_2. \text{let } \langle x,y \rangle = \text{EPR}^* \text{ in } ...) \text{ 1 1 }] \rightarrow$ 
 \\
 $[\ket{00}, \text{let } \langle x,y \rangle = \text{CNOT} \langle H p_0, p_1 \rangle \text{ in } \dots] \rightarrow$
 \\
 $[\frac{1}{\sqrt{2}}(\ket{00} + \ket{10}), \text{let } \langle x,y \rangle = \text{CNOT} \langle p_0, p_1 \rangle \text{ in } \dots] \rightarrow$
 \\
 $[\frac{1}{\sqrt{2}}(\ket{00} + \ket{11}), \text{let } \langle x,y \rangle = \langle p_0, p_1 \rangle \text{ in } \dots] \rightarrow$
 \\
 $[\frac{1}{\sqrt{2}} (\ket{00} + \ket{11}), \text{let } a = U p_0 \langle 1, 1 \rangle \text{ in } \dots] \rightarrow$
 \\
 (Evaluamos $U p_0 \langle 1, 1 \rangle \rightarrow U_{11} p_0$. Aplicamos $Z X$ sobre $p_0$. $\ket{0} \to \ket{1}, \ket{1} \to -\ket{0}$)
 \\
 $[\frac{1}{\sqrt{2}} (\ket{01} - \ket{10}), \text{let } a = p_0 \text{ in } \text{let } \langle q_1,q_2 \rangle = \text{CNOT} \langle a,p_1 \rangle \text{ in } \dots] \rightarrow$
 \\
 $[\frac{1}{\sqrt{2}} (\ket{01} - \ket{10}), \text{let } \langle q_1,q_2 \rangle = \text{CNOT} \langle p_0,p_1 \rangle \text{ in } \dots] \rightarrow$
 \\
 $[\frac{1}{\sqrt{2}} (\ket{01} - \ket{11}), \text{let } \langle q_1,q_2 \rangle = \langle p_0, p_1 \rangle \text{ in } \langle \text{meas}(H q_1), \text{meas } q_2 \rangle] \rightarrow$
 \\
 $[\frac{1}{\sqrt{2}} (\ket{01} - \ket{11}), \langle \text{meas}(H p_0), \text{meas } p_1 \rangle] \rightarrow$
 \\
 (Aplicamos $H$ a $p_0$. Notar que el estado es $\ket{-}\otimes\ket{1}$. $H\ket{-} = \ket{1}$)
 \\
 $[\ket{11}, \langle \text{meas } p_0, \text{meas } p_1 \rangle] \rightarrow$
 \\
 $[\ket{11}, \langle 1, 1 \rangle]$

\section{Algoritmo en cálculo lambda $\mathcal{L}_{\mathcal{B}}$}

\subsection{Definición del algoritmo}

En este cálculo, definimos el tipo qubit puro como $\pqbit \defeq \one \pwith \one$.
Los vectores de la base computacional se codifican como:
\[ \ket{0} \defeq \p{\pair{\ast}{0 \sdot \ast}} \quad \text{y} \quad \ket{1} \defeq \p{\pair{0 \sdot \ast}{\ast}} \]

Las compuertas lógicas cuánticas ($X, Z, H, CNOT$) se definen como términos puros $\p U$ que actúan linealmente sobre los términos. Por ejemplo, $X$ intercambia los componentes del par.

El algoritmo de condensación se construye en el fragmento mixto usando el operador de embebido $\mathcal{B}$.
Asumimos que tenemos términos puros para las transformaciones:
\begin{itemize}
    \item $\p{EPR}$: Término de tipo $\pqbit \otimes \pqbit$ que representa $\beta_{00}$.
    \item $\p{U}_{b_1 b_2}$: Transformación unitaria local de Alice (dependiente de los bits clásicos).
    \item $\p{BobOp}$: Composición de $H \otimes I$ y $CNOT$ que aplica Bob.
\end{itemize}

\subsection{Construcción del término completo}

A continuación, desarrollamos las definiciones explícitas de los componentes.

Definimos los operadores base:
\begin{align*}
    \p{X} &\defeq \lambda x. \elimwith^1(x, \_. \ket{1}) \Plus \elimwith^2(x, \_. \ket{0}) \\
    \p{Z} &\defeq \lambda x. \elimwith^1(x, \_. \ket{0}) \Plus \elimwith^2(x, \_. (-1) \sdot \ket{1}) \\
    \p{H} &\defeq \frac{1}{\sqrt{2}} \sdot (\p X \Plus \p Z)
\end{align*}

El operador CNOT se define siguiendo la definición estándar del paper, en el ejemplo 5.7:

\[
\p{CNOT} \defeq \lambda z. \elimtens\Big(z, x y.
    \tfrac{1}{2} (x \otimes y) \Plus
    \tfrac{1}{2} (\p Z x \otimes y) \Plus
    \tfrac{1}{2} (x \otimes \p X y) \Plus
    \tfrac{-1}{2} (\p Z x \otimes \p X y)\Big)
\]

Definimos el operador de Alice generalizado $\p{AliceOp}(b_1, b_2)$ que aplica $Z^{b_1} X^{b_2}$ al par x. Recordamos que $\p{M}^0 = \p I$ y $\p M^1 = \p M$.

\[
\p{U}_{b_1 b_2} \defeq \lambda x. Z ^{b_1} X ^{b_2} x
\]

El operador de Alice sobre el par EPR es:
\[
\p{AliceOp}(b_1, b_2) \defeq \lambda w. \elimtens(w, x y. (\p{U}_{b_1 b_2} x) \otimes y)
\]

El operador de Bob ($\p{BobOp} = (\p H \otimes \p{id}) \circ \p{CNOT}$):
\[
\p{BobOp} \defeq \lambda w. \elimtens(\p{CNOT} \text{ } w, x y. (\p H x) \otimes y)
\]

El estado inicial EPR:
\[
\p{EPR} \defeq \frac{1}{\sqrt{2}} \sdot (\ket{0} \otimes \ket{0} \Plus \ket{1} \otimes \ket{1})
\]

Finalmente, definimos el término completo como una función en el fragmento mixto que toma dos bits clásicos (de tipo $\mathbb{B} = \one \oplus \one$) y produce el estado final medido.
Presentamos la definición usando una notación de casos, que se implementa formalmente mediante eliminadores de suma anidados ($\elimplus$):

\[
\text{Condensacion} \defeq \lambda b_1 b_2. Term_{b_1 b_2}
\]

Donde $Term_{b_1 b_2}$ es el término mixto definido anteriormente, instanciado con los operadores puros fijos correspondientes:
\[
\text{Term}_{ij} \defeq \text{Meas} \left( \mathcal{B} \left( \p{BobOp} (\p{AliceOp}_{ij} \, \p{EPR}) \right) \right)
\]
Con $\p{AliceOp}_{ij} = \lambda w. \elimtens(w, x y. (\p Z^i (\p X^j x)) \otimes y)$.

Donde $\text{Meas}$ es el término que define la medición en la base computacional, construido como la suma de los proyectores $\p P_{ij} = \ketbra{ij}{ij}$ (análogo al Ejemplo 5.7 del paper):
\[
\text{Meas} \defeq \mathcal{B}(\p P_{00}) \Plus \mathcal{B}(\p P_{01}) \Plus \mathcal{B}(\p P_{10}) \Plus \mathcal{B}(\p P_{11})
\]
Al evaluar $\text{Condensacion} \ \text{True} \ \text{True}$, el término se reduce a $\text{Term}_{11}$, que a su vez reduce a $\mathcal{B}(\ket{11})$.

\subsection{Tipo del término}

El término $\text{Condensacion}$ es una función en el fragmento mixto.
Si definimos el tipo booleano como $\mathbb{B} \defeq \one \oplus \one$, entonces:
\[ \vdash \text{Condensacion} : \mathbb{B} \multimap \mathbb{B} \multimap \mathcal{B}(\pqbit \otimes \pqbit) \]


\subsection{Traza de ejecución en $\mathcal{L}_{\mathcal{B}}$ (caso $b_1=1, b_2=1$)}

Analizamos la reducción de $\text{Condensacion} \ \text{True} \ \text{True}$.
1. La aplicación de las lambdas y los ``if'' reduce el término a $\text{Term}_{11}$.
2. La ejecución continúa dentro del operador $\mathcal{B}$ siguiendo las reglas del fragmento puro hasta la medición final.

\noindent \textbf{1. Estado inicial:}
\[ \p{EPR} \rightarrow \frac{1}{\sqrt{2}} (\ket{00} + \ket{11}) \]

\noindent \textbf{2. Operación de Alice ($\p U_{11} = \p Z \otimes \p I \circ \p X \otimes \p I$):}
Alice aplica $X$ y luego $Z$ al primer qubit.
\begin{align*}
    (\p X \otimes \p I) \p{EPR} &\rightarrow \frac{1}{\sqrt{2}} (\ket{10} + \ket{01}) \\
    (\p Z \otimes \p I) (\dots) &\rightarrow \frac{1}{\sqrt{2}} (-\ket{10} + \ket{01}) = \frac{1}{\sqrt{2}} (\ket{01} - \ket{10})
\end{align*}

\noindent \textbf{3. Operación de Bob - CNOT:}
Bob aplica CNOT sobre el par recibido. Recordamos que $\text{CNOT} \ket{10} = \ket{11}$ y $\text{CNOT} \ket{01} = \ket{01}$.
\[
    \p{CNOT} \left( \frac{1}{\sqrt{2}} (\ket{01} - \ket{10}) \right) \rightarrow \frac{1}{\sqrt{2}} (\ket{01} - \ket{11})
\]
Factorizando el segundo qubit ($\ket{1}$), el estado es:
\[ \frac{1}{\sqrt{2}} (\ket{0} - \ket{1}) \otimes \ket{1} = \ket{-} \otimes \ket{1} \]

\noindent \textbf{4. Operación de Bob - Hadamard:}
Bob aplica $H$ al primer qubit. Dado que $\p H \ket{-} = \ket{1}$:
\[
    (\p H \otimes \p I) (\ket{-} \otimes \ket{1}) \rightarrow \ket{1} \otimes \ket{1} = \ket{11}
\]

\noindent \textbf{5. Medición final:}
El término ha reducido a $\mathcal{B}(\ket{11})$. Al aplicar $\text{Meas}$, que es la suma de proyectores $\mathcal{B}(\p P_{ij})$, el único término que no se anula es $\mathcal{B}(\p P_{11})$.
\[
    \text{Meas} (\mathcal{B}(\ket{11})) \rightarrow \dots \rightarrow \mathcal{B}(\ket{11})
\]
Esto confirma que los bits recuperados son $1$ y $1$.

\end{document}
